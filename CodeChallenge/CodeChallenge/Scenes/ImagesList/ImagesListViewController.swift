//
//  ImagesListViewController.swift
//  CodeChallenge
//
//  Created by Cesar Brenes on 19/2/21.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ImagesListDisplayLogic: class {
    func displayDataSourceSuccess(viewModel: ImagesList.DataSource.ViewModel.Succes)
    func displayDataSourceErrorFound(viewModel: ImagesList.DataSource.ViewModel.ErrorFound)
    func displayDataSourceEmptyState(viewModel: ImagesList.DataSource.ViewModel.EmptyState)
}

class ImagesListViewController: UIViewController, ImagesListDisplayLogic {
    var interactor: ImagesListBusinessLogic?
    var router: (NSObjectProtocol & ImagesListRoutingLogic & ImagesListDataPassing)?
    
    // MARK: OUTLETS
    @IBOutlet weak var tableView: UITableView!
    
    // MARK: PROPERTIES
    var refreshControl = UIRefreshControl()
    var dataSource = [ImagesList.DataSource.ViewModel.Succes.DisplayObject]()
    let activityIndicator = UIActivityIndicatorView(style: .gray)
    /**
     The API doesn't have a way to know the total number of elements, this means the app needs to make multiples requests to reach the end of the list, this variable(totalNumberOfElements) will control when the user can request or not more elements
     */
    var totalNumberOfElements = 0
    let heightForCustomCell: CGFloat = 156
    
    var actionInstance = UIAlertAction.self // These two properties are necessary to mock the action for unit testing
    var actionString: String?
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    
    private func setup() {
        let viewController = self
        let interactor = ImagesListInteractor()
        let presenter = ImagesListPresenter()
        let router = ImagesListRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: Routing
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad() {
        super.viewDidLoad()
        title = LocalizationHelper.photos.localizedString()
        activityIndicator.transform = CGAffineTransform(scaleX: 3, y: 3)
        refreshControl.addTarget(self, action: #selector(self.refresh(_:)), for: .valueChanged)
        tableView.addSubview(refreshControl)
        tableView.backgroundView = activityIndicator
        registerCustomCells()
        requestDataSource(isRefreshAction: false)
    }
    
    func registerCustomCells() {
        let nib = UINib(nibName: String(describing: ImageListTableViewCell.self), bundle: nil)
        tableView.register(nib, forCellReuseIdentifier: String(describing: ImageListTableViewCell.self))
    }
    
    // MARK: Request Methods
    func requestDataSource(isRefreshAction: Bool) {
        activityIndicator.startAnimating()
        let request = ImagesList.DataSource.Request(isRefreshAction: isRefreshAction)
        interactor?.requestDataSource(request: request)
    }
    
    // MARK: Display Methods
    func displayDataSourceErrorFound(viewModel: ImagesList.DataSource.ViewModel.ErrorFound) {
        DispatchQueueHelper.executeInMainThread { [weak self] in
            guard let self = self else {
                return
            }
            let alertController = UIAlertController(title: viewModel.title, message: viewModel.message, preferredStyle: .alert)
            let leftButtonAction = self.actionInstance.makeActionWithTitle(title: viewModel.leftButtonTitle, style: .cancel) { [weak self] (_) in
                self?.handleCancelAction(viewModel: viewModel)
            }
            let rightButtonAction = self.actionInstance.makeActionWithTitle(title: viewModel.rightButtonTitle, style: .default) {[weak self] (_) in
                self?.actionString = viewModel.rightButtonTitle
                self?.requestDataSource(isRefreshAction: !(self?.refreshControl.isHidden ?? true))
            }
            alertController.addAction(leftButtonAction)
            alertController.addAction(rightButtonAction)
            self.router?.presentAlertController(alertController: alertController)
        }
    }
    
    func displayDataSourceSuccess(viewModel: ImagesList.DataSource.ViewModel.Succes) {
        DispatchQueueHelper.executeInMainThread { [weak self] in
            guard let self = self else {
                return
            }
            self.tableView.restore()
            self.refreshControl.endRefreshing()
            self.activityIndicator.stopAnimating()
            self.totalNumberOfElements = viewModel.totalNumberOfElements
            guard let indexPathListToInsert = viewModel.indexPathToInsert else {
                if self.dataSource.isEmpty || viewModel.numberOfPreviousItems == 0 {
                    self.dataSource = viewModel.displayObjects
                }
                self.tableView.reloadData()
                return
            }
            self.dataSource += viewModel.displayObjects
            self.tableView.insertRows(at: indexPathListToInsert, with: .bottom)
        }
    }
    
    func displayDataSourceEmptyState(viewModel: ImagesList.DataSource.ViewModel.EmptyState) {
        DispatchQueueHelper.executeInMainThread { [weak self] in
            self?.refreshControl.endRefreshing()
            self?.activityIndicator.stopAnimating()
            self?.tableView.setStateMessage(message: viewModel.message)
        }
    }
    
    @objc func refresh(_ sender: AnyObject) {
        requestDataSource(isRefreshAction: true)
    }
    
    func handleCancelAction(viewModel: ImagesList.DataSource.ViewModel.ErrorFound) {
        self.actionString = viewModel.leftButtonTitle
        if !self.refreshControl.isHidden {
            self.dataSource.removeAll()
            self.totalNumberOfElements = 0
            self.tableView.setStateMessage(message: viewModel.tableViewErrorMessage)
        } else if self.dataSource.isEmpty {
            self.tableView.setStateMessage(message: viewModel.tableViewErrorMessage)
        } else {
            self.tableView.restore()
        }
        self.refreshControl.endRefreshing()
        self.activityIndicator.stopAnimating()
    }
}

extension ImagesListViewController: UITableViewDelegate, UITableViewDataSource {
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return totalNumberOfElements
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard let cell = tableView.dequeueReusableCell(withIdentifier: String(describing: ImageListTableViewCell.self)) as? ImageListTableViewCell else {
            return UITableViewCell()
        }
        if indexPath.row >= dataSource.count {
            cell.setupCell(item: nil) // This allows to show a loading view instead of the normal cell content
        } else {
            cell.setupCell(item: dataSource[indexPath.row])
        }
        return cell
    }
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return heightForCustomCell
    }
    
    /**
     This method is the key to request more elements when the user is doing scroll down
     */
    func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {
        if totalNumberOfElements > 0 && indexPath.row >= dataSource.count {
            requestDataSource(isRefreshAction: false)
        }
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        router?.presentDetailViewController(index: indexPath.row)
    }
}
