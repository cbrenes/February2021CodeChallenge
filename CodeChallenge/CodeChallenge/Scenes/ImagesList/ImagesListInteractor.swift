//
//  ImagesListInteractor.swift
//  CodeChallenge
//
//  Created by Cesar Brenes on 19/2/21.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ImagesListBusinessLogic {
    func requestDataSource(request: ImagesList.DataSource.Request)
}

protocol ImagesListDataStore {
    func getURL(index: Int) -> String?
}
/**
 This class handles the communication between the API service and the other layers, it handles the pagination logic too
 In the case the server is down for some reason we can still using the app making a little change in the worker: var worker = APIWorker(store: MockAPI())
 This will start using a mock api instead of the real server
 */
class ImagesListInteractor: ImagesListBusinessLogic, ImagesListDataStore {
    var presenter: ImagesListPresentationLogic?
    var worker = APIWorker(store: (JsonPlaceHolderService()))
    
    let limitOfElementPerRequest = 20
    var items = [ImageItem]()
    var isFetchInProgress = false // This variable avoids consecutive calls to the request data to the API
    
    func requestDataSource(request: ImagesList.DataSource.Request) {
        if isFetchInProgress {
            return
        }
        isFetchInProgress = true
        handleRequestDataSource(request: request)
    }
    
    func getURL(index: Int) -> String? {
        if index < items.count {
            return items[index].url
        }
        return nil
    }
}

extension ImagesListInteractor {
    func handleRequestDataSource(request: ImagesList.DataSource.Request) {
        let start = request.isRefreshAction ? 0 : items.count
        worker.getData(start: start, limit: limitOfElementPerRequest, completionHandler: { [weak self] in
            guard let self = self else { return }
            self.isFetchInProgress = false
            switch $0 {
            case let .failure(error):
                if error == .noData {
                    self.handleApiSuccessAnswer(isRefreshAction: request.isRefreshAction, itemsFromAPI: [ImageItem]())
                    return
                }
                let totalNumberOfElements = self.getNumberOfElementsToDisplay(itemsFromApi: [ImageItem](), previousItems: self.items, errorFound: error)
                self.presenter?.presentDataSource(response: ImagesList.DataSource.Response(numberOfPreviousItems: self.items.count, items: nil, totalNumberOfElements: totalNumberOfElements, errorFound: error))
            case let .success(itemsFromAPI):
                self.handleApiSuccessAnswer(isRefreshAction: request.isRefreshAction, itemsFromAPI: itemsFromAPI)
            }
        })
    }
    
    func handleApiSuccessAnswer(isRefreshAction: Bool, itemsFromAPI: [ImageItem]) {
        if isRefreshAction {
            self.items.removeAll()
        }
        let totalNumberOfElements = self.getNumberOfElementsToDisplay(itemsFromApi: itemsFromAPI, previousItems: self.items, errorFound: nil)
        let numberOfPreviousItems = self.items.count
        self.items += itemsFromAPI
        self.presenter?.presentDataSource(response: ImagesList.DataSource.Response(numberOfPreviousItems: numberOfPreviousItems, items: itemsFromAPI, totalNumberOfElements: totalNumberOfElements, errorFound: nil))
    }
    
    func getNumberOfElementsToDisplay(itemsFromApi: [ImageItem], previousItems: [ImageItem], errorFound: APIError?) -> Int {
        if previousItems.isEmpty && errorFound != nil {
            return 0
        }
        if itemsFromApi.isEmpty && errorFound == nil {
            return previousItems.count
        }
        var valueToKnowIfNeedToGetMoreElements = 1
        if (itemsFromApi.count != limitOfElementPerRequest) && errorFound == nil {
            valueToKnowIfNeedToGetMoreElements = 0
        }
        return itemsFromApi.count + previousItems.count + valueToKnowIfNeedToGetMoreElements
    }
}
